<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>Spring MVC | 唐宋的个人博客</title>
<meta name="description" content="&lt;img src=&#34;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1576067917477&amp;di=981af9e2e885994371221c478cfd625d&amp;imgtype=jpg&amp;src=http%3A%2F%2Fimg1.imgtn.bdimg.com%2Fit%2Fu%3D1205038546%2C1747959657%26fm%3D214%26gp%3D0.jpg&#34; /&gt;">

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="shortcut icon" href="https://tangsongyuanmingqing1.github.io/favicon.ico?v=1576068226601">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://unpkg.com/papercss@1.6.1/dist/paper.min.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://tangsongyuanmingqing1.github.io/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>


<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />


  </head>
  <body>
  
    <nav class="navbar border fixed split-nav">
  <div class="nav-brand">
    <h3><a href="https://tangsongyuanmingqing1.github.io">唐宋的个人博客</a></h3>
  </div>
  <div class="collapsible">
    <input id="collapsible1" type="checkbox" name="collapsible1">
    <button>
      <label for="collapsible1">
        <div class="bar1"></div>
        <div class="bar2"></div>
        <div class="bar3"></div>
      </label>
    </button>
    <div class="collapsible-body">
      <ul class="inline">
        
          <li>
            
              <a href="/" class="menu">
                首页
              </a>
            
          </li>
        
          <li>
            
              <a href="/archives" class="menu">
                文档
              </a>
            
          </li>
        
          <li>
            
              <a href="/tags" class="menu">
                标签
              </a>
            
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div id="top" class="row site">
      <div class="sm-12 md-8 col">
        <div class="paper">
          <article class="article">
            <h1>Spring MVC</h1>
            <p class="article-meta">
              2018-04-04
              
                <a href="https://tangsongyuanmingqing1.github.io/tag/7i8WPTon8" class="badge secondary">
                  spring
                </a>
              
            </p>
            
            <div class="post-content">
              <p>学习Spring MVC的个人总结</p>
<!-- more -->
<h2 id="什么是mvc设计模式">什么是MVC设计模式</h2>
<p>MVC里面的M指的的Model（通常包含bean、dao(mapper)、service）；V指的是View，视图层，视图层主要的技术（JSP、HTML、FreeMaker、Themeleaf）；C指的是Controller，控制层。控制层不负责具体数据、逻辑的处理和运算，它只负责将Model层的结果返回给对应的视图层去展示。</p>
<p>在JavaWeb阶段， Controller层指的就是Servlet； View层指的就是JSP或者HTML;  Model层指的就是bean、dao、service。</p>
<p>在J2EE阶段，Controller层指的就是SpringMVC、Structs1\2；  View层不变还是主流的页面展示技术; Model层包括bean、mybatis、service。</p>
<h2 id="springmvc的优势">SpringMVC的优势</h2>
<h3 id="1-使用简单">1. 使用简单</h3>
<p>SpringMVC是一款很轻量级的框架，要使用它的组件我们往往只需要定义一些最简单的Java类，然后添加某些注解就可以了</p>
<h3 id="2-无侵入性">2. 无侵入性</h3>
<p>SpringMVC的参数注入只直接注入到方法中，可以很好的做到不同请求间数据的隔离，而Struts2是注入到类实例变量上，不同的请求可能会覆盖参数。</p>
<h3 id="3-兼容性好">3. 兼容性好</h3>
<p>SpringMVC可以很轻易的和Spring整合，而Struts需要做比较复杂的配置。</p>
<h2 id="springmvc-的简单使用">SpringMVC 的简单使用</h2>
<h3 id="1-添加依赖">1. 添加依赖</h3>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
    &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="2-在webxml中配置dispatcherservlet">2. 在web.xml中配置DispatcherServlet</h3>
<pre><code class="language-xml">&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee     http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;
         version=&quot;3.1&quot;&gt;

  &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;!-- 指定SpringMVC 配置文件位置，DispatcherServlet初始化时会初始化Spring上下文（WebApplicationContext） --&gt;
        &lt;!-- 默认配置文件寻找位置：/WEB-INF/{servlet-name}-servlet.xml，如果名字符合默认寻找规则，可以不指定配置文件路径 --&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;/WEB-INF/dispatcher-servlet.xml&lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;!-- 配置容器启动时初始化DispatcherServlet --&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</code></pre>
<h3 id="3-配置springmvc-dispatcher-servletxml">3. 配置SpringMVC  dispatcher-servlet.xml</h3>
<pre><code class="language-xml">&lt;!-- SpringMVC大部分组件都有默认配置，我们一般简单应用只需要指定视图解析器就行了 --&gt;
&lt;!-- 配置视图解析器，用于将Handler方法中返回的视图名解析成真正可展示的页面 --&gt;
&lt;mvc:view-resolvers&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/&quot; /&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;
&lt;/mvc:view-resolvers&gt;
</code></pre>
<h3 id="4-定义controller和请求处理方法handler">4. 定义Controller和请求处理方法（Handler)</h3>
<pre><code class="language-java">@Controller
public class SpringMVCTest {
    @RequestMapping(&quot;/hello&quot;)
    public String sayHallow(String name, Model model){
        model.addAttribute(&quot;mess&quot;,&quot;hello world&quot;);
        return &quot;SayHello&quot;;
    }
}
</code></pre>
<pre><code class="language-html">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;首页&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;a href=&quot;/hello&quot; &gt;hello&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="language-html">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;hello&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;p&gt;${mess}&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="springmvc主要组件">SpringMVC主要组件</h2>
<h3 id="视图解析器">视图解析器</h3>
<p>视图解析器的作用是将请求处理方法中的返回值解析成一个真正可以渲染的页面。</p>
<h4 id="常用的视图解析器">常用的视图解析器</h4>
<ul>
<li>
<p>InternalResourceViewResolver</p>
<p>内部资源解析器： 用于将返回值对应到项目路径下的某个可显示的页面。比如方法返回值是index字符串，那么<code>InternalResourceViewResolver</code>解析器会在index前加上指定的前缀，在index后加上指定的后缀来拼接成指向某个视图的路径。</p>
<pre><code class="language-xml">&lt;!-- 配置视图解析器，用于将Handler方法中返回的视图名解析成真正可展示的页面 --&gt;
&lt;mvc:view-resolvers&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/&quot; /&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;
&lt;/mvc:view-resolvers&gt;
</code></pre>
</li>
</ul>
<h3 id="参数传递">参数传递</h3>
<h4 id="页面参数传递到controller">页面参数传递到Controller</h4>
<h5 id="requestparam">@RequestParam</h5>
<p>请求参数可以直接定义到方法参数里，并通过@RequestParam(&quot;key&quot;)注解修饰参数，这样SpringMVC会自动解析请求中的参数给你填充到方法参数中。</p>
<blockquote>
<p>注意：此注解修饰的参数默认是必传的，如果请求中没有此参数会直接报错，可以通过设置此注解的required属性为false解决</p>
</blockquote>
<h5 id="requestheader">@RequestHeader</h5>
<p>获取请求头参数</p>
<h5 id="requestattribute">@RequestAttribute</h5>
<p>获取作用域request数据</p>
<h5 id="sessionattribute">@SessionAttribute</h5>
<p>获取作用域session数据</p>
<h5 id="cookievalue">@CookieValue</h5>
<p>获取cookie数据</p>
<blockquote>
<p>如果前端传的参数名和后端方法中的参数名相同可以不用写value属性</p>
</blockquote>
<pre><code class="language-html">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
   &lt;title&gt;首页&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
   &lt;%
       String sex = &quot;男&quot;;
       session.setAttribute(&quot;sex&quot;,sex);
   %&gt;
   &lt;a href=&quot;/hello?name=张三&amp;id=5&amp;age=25&quot; &gt;hello&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="language-java">package com.lanou.springmvc.service;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.Map;

@Controller
public class SpringMVCTest {

    @RequestMapping(&quot;/hello&quot;)
    public String sayHallow(
            String name,
            @RequestHeader(value = &quot;User-Agent&quot;)
                    String userAgent,
            @CookieValue(value = &quot;JSESSIONID&quot;)
                    String jsessionid,
            @SessionAttribute
                    String sex,
            @RequestParam
                    int id,
            @RequestAttribute
                    String age,
            Model model
    ){
        System.out.println(name);
        System.out.println(&quot;获取RequestHeader：&quot; + userAgent);
        System.out.println(&quot;获取cookie：&quot; + jsessionid);
        System.out.println(&quot;获取作用域session中的数据：&quot; + sex);
        System.out.println(&quot;获取RequestParam：&quot; + id);
        System.out.println(&quot;获取作用域request中的数据：&quot; + age);
        return &quot;SayHello&quot;;
    }
}
</code></pre>
<h4 id="controller中的数据传递到页面">Controller中的数据传递到页面</h4>
<pre><code class="language-html">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;hello&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;p&gt;${name}&lt;/p&gt;
    &lt;p&gt;${id}&lt;/p&gt;
    &lt;p&gt;${jsessionid}&lt;/p&gt;
    &lt;p&gt;${sex}&lt;/p&gt;
    &lt;p&gt;${userAgent}&lt;/p&gt;
    &lt;p&gt;${mess}&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h5 id="model">Model</h5>
<pre><code class="language-java">package com.lanou.springmvc.service;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.Map;

@Controller
public class SpringMVCTest {

    @RequestMapping(&quot;/hello&quot;)
    public String sayHallow(Model model){
        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;name&quot;,name);
        map.put(&quot;userAgent&quot;,userAgent);
        map.put(&quot;jsessionid&quot;,jsessionid);
        map.put(&quot;sex&quot;,sex);
        map.put(&quot;id&quot;,id);
        map.put(&quot;age&quot;,age);
        //传多个参数时
        model.addAllAttributes(map);
        //只传一个参数时
        model.addAttribute(&quot;mess&quot;,&quot;hello world&quot;);
        return &quot;SayHello&quot;;
    }
}
</code></pre>
<h5 id="modelandview">ModelAndView</h5>
<pre><code class="language-java">package com.lanou.springmvc.service;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.ModelAndView;

import java.util.HashMap;
import java.util.Map;

@Controller
public class SpringMVCTest {

    @RequestMapping(&quot;/hello&quot;)
    public ModelAndView sayHallow(ModelAndView ma){
        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;name&quot;,name);
        map.put(&quot;userAgent&quot;,userAgent);
        map.put(&quot;jsessionid&quot;,jsessionid);
        map.put(&quot;sex&quot;,sex);
        map.put(&quot;id&quot;,id);
        map.put(&quot;age&quot;,age);
		//传多个参数时
        ma.addAllObjects(map);
        //只传一个参数时
        ma.addObject(&quot;mess&quot;,&quot;hello world&quot;);
        ma.setViewName(&quot;SayHello&quot;);
        return ma;
    }

}

</code></pre>
<h1 id="mybatis">Mybatis</h1>
<h2 id="mybatis介绍">Mybatis介绍</h2>
<p>​		MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。</p>
<h2 id="mybatis简单使用">Mybatis简单使用</h2>
<h3 id="编写核心配置文件">编写核心配置文件</h3>
<p>SqlSessionFactory对象需要从一个核心配置文件中构建，因此我们创建SqlSessionFactory对象之前需要先配置一个Mybatis核心配置文件</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;!-- 引入外部properties文件,路径从类路径的根目录开始 --&gt;
    &lt;properties resource=&quot;jdbc.properties&quot; /&gt;

    &lt;settings&gt;
        &lt;!-- 开启将数据库中下划线连接的字段自动映射为Java的小驼峰命名 --&gt;
        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;
    &lt;/settings&gt;

    &lt;!-- 定义类型别名，在xxxMapper.xml文件中就可以用别名代替很长的类名 --&gt;
    &lt;typeAliases&gt; 
        &lt;!-- 单个类配置别名 --&gt;
		&lt;!-- &lt;typeAlias type=&quot;com.lanou3g.mybatis.bean.User&quot; alias=&quot;User&quot; /&gt; --&gt;
        
        &lt;!-- 统一配置某个包下所有类的别名, 会使用 Bean 的首字母小写的类名来作为它的别名。 --&gt;
        &lt;package name=&quot;com.lanou3g.mybatis.bean&quot; /&gt;
    &lt;/typeAliases&gt;

    &lt;!-- 配置不同环境的参数 --&gt;
    &lt;environments default=&quot;development&quot;&gt;
        &lt;!-- 开发环境数据库、事务配置 --&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;!-- 事务管理使用JDBC的事务 --&gt;
            &lt;transactionManager type=&quot;JDBC&quot;/&gt;
            &lt;!-- 配置开发环境数据源 --&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;${jdbc.user}&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;
                &lt;!-- 将所有driver.开头的参数，附加到url属性的值后面上 --&gt;
                &lt;property name=&quot;driver.characterEncoding&quot; value=&quot;utf8&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;

    &lt;!-- 将mapper SQL映射文件包含进来 --&gt;
    &lt;mappers&gt;
        &lt;!-- 将通过XML方式配置的mapper引入进来 --&gt;
        &lt;mapper resource=&quot;mapper/userMapper.xml&quot;/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<h3 id="编写mapper对象的xml配置文件">编写Mapper对象的xml配置文件</h3>
<p>XML格式的Mapper配置文件类似于接口的实现类，它指定了具体要执行的SQL语句，以及结果集如何映射。</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.lanou3g.mybatis.mapper.UserMapper&quot;&gt;
    &lt;select id=&quot;queryAllUser&quot; resultType=&quot;user&quot;&gt;
        select * from user
     &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<h3 id="构建mapper类">构建Mapper类</h3>
<pre><code class="language-java">public interface UserMapper {
     List&lt;User&gt; queryAllUser();
}
</code></pre>
<h3 id="构建对象">构建对象</h3>
<pre><code class="language-java">// 1. 初始化mybatis配置
String confPath = &quot;mybatis_conf.xml&quot;;
InputStream in = Resources.getResourceAsStream(confPath);

// 2. 构建SqlSessionFactory对象
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in);

// 3. 获取SqlSession对象（默认事务不自动提交）
// 通过上一步的SqlSessionFactory对象可以获取到负责执行SQL语句的SqlSession对象
// SqlSession sqlSession = sqlSessionFactory.openSession();
// 获取一个自动提交事务的sqlSession
SqlSession sqlSession = sqlSessionFactory.openSession(true);

// 4. 获取Mapper
// 用SqlSession对象从Mybatis中获取Mapper接口的实现类
UserMapper mapper = sqlSession.getMapper(UserMapper.class);
</code></pre>
<h2 id="深入了解mybatis">深入了解Mybatis</h2>
<h3 id="主要组件">主要组件</h3>
<h4 id="核心配置文件">核心配置文件</h4>
<p>核心配置文件是Mybatis的入口，它里面可以配置mybatis的具体参数、数据源、类型别名、关联映射文件等。。</p>
<p>具体的参数配置说明参见：</p>
<p><a href="https://mybatis.org/mybatis-3/zh/configuration.html">Mybatis3核心配置文件官方说明</a></p>
<h4 id="sqlsessionfactory">SqlSessionFactory</h4>
<p>一个SqlSessionFactory只能连接一个数据库实例，如果需要连接多个数据库，需要构建多个SqlSessionFactory对象。</p>
<p>在构建SqlSesssionFactory时可以指定environment的id，表示使用指定的数据源来构建factory对象</p>
<pre><code class="language-java">SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in, &quot;dev&quot;);
</code></pre>
<h4 id="sqlsession">SqlSession</h4>
<p>一个SqlSession对象代表一次到数据的会话，该对象有一下功能：</p>
<ul>
<li>获取Mapper实现类</li>
<li>管理事务操作</li>
</ul>
<blockquote>
<p>注意： SqlSession对象是非线程安全的，在多线程环境下，建议不要作为类的实例属性来用。</p>
</blockquote>
<h4 id="mapper">Mapper</h4>
<ul>
<li>
<p>Mapper接口类</p>
<p>定义了增删盖查的方法。注意，必须是接口类型，而且方法只需要定义就可以了。</p>
</li>
<li>
<p>Mapper配置文件</p>
<p>Mapper配置文件中就是负责实现接口中的方法，它定义了具体要执行什么SQL语句，如何映射结果集。</p>
<ul>
<li>配置文件中select、delete、update、insert标签的id必须是对应接口中的方法名。</li>
<li>mapper文件的namespace属性需要对应Mapper接口的完全类型限定名。</li>
</ul>
</li>
</ul>
<h3 id="深入mybatis核心配置文件">深入Mybatis核心配置文件</h3>
<p>具体的参数配置说明参见：</p>
<p><a href="https://mybatis.org/mybatis-3/zh/configuration.html">Mybatis3核心配置文件官方说明</a></p>
<h3 id="深入mybatis映射配置文件">深入Mybatis映射配置文件</h3>
<h4 id="crud语句定义">CRUD语句定义</h4>
<h5 id="查询语句">查询语句</h5>
<p>接口中</p>
<pre><code class="language-java">List&lt;User&gt; queryAllUser();

User queryUserById(Integer id);
</code></pre>
<p>xml配置文件中</p>
<pre><code class="language-xml">&lt;select id=&quot;queryAllUser&quot; resultType=&quot;user&quot;&gt;
    select * from user
&lt;/select&gt;

&lt;select id=&quot;queryUserById&quot; resultType=&quot;user&quot;&gt;
    select * from user where id = #{id}
&lt;/select&gt;
</code></pre>
<h5 id="插入语句">插入语句</h5>
<h6 id="普通插入语句">普通插入语句</h6>
<p>接口中</p>
<pre><code class="language-java">int insertUser(User user);
</code></pre>
<p>xml配置文件中</p>
<pre><code class="language-xml">&lt;insert id=&quot;insertUser&quot;&gt;
    insert into user (username,nick_name,email)
    values (#{username},#{nickName},#{email})
&lt;/insert&gt;
</code></pre>
<h6 id="如何返回数据库自增的id">如何返回数据库自增的ID</h6>
<pre><code class="language-xml">&lt;!-- 给insert语句添加useGeneratedKeys、keyProperty后，mybatis会将自增的id值直接赋值到传进来的user对象的id属性上
        useGeneratedKeys: 指定需要获取数据库自增的id
        keyProperty: 指定自增地段的名称
     --&gt;
&lt;insert id=&quot;insertUser&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
    insert into user (username,nick_name,email)
    values (#{username},#{nickName},#{email})
&lt;/insert&gt;
</code></pre>
<h5 id="删除语句">删除语句</h5>
<p>接口中</p>
<pre><code class="language-java">void deleteUserById(Integer id);
</code></pre>
<p>XML配置中</p>
<pre><code class="language-xml">&lt;delete id=&quot;deleteUserById&quot;&gt;
    delete from user where id = #{id}
&lt;/delete&gt;
</code></pre>
<h5 id="更新语句">更新语句</h5>
<p>接口中</p>
<pre><code class="language-java">void updateUser(User user);
</code></pre>
<p>XML配置中</p>
<pre><code class="language-xml">&lt;update id=&quot;updateUser&quot;&gt;
    update user set password = #{password} where id = #{id}
&lt;/update&gt;
</code></pre>
<h4 id="接口中的参数如何传递到sql中">接口中的参数如何传递到SQL中</h4>
<h5 id="简单类型参数">简单类型参数</h5>
<p>接口中：</p>
<pre><code class="language-java">void deleteUserById(Integer id);
</code></pre>
<p>xml配置文件中：</p>
<pre><code class="language-xml">&lt;delete id=&quot;deleteUserById&quot;&gt;
    delete from user where id = #{id}
&lt;/delete&gt;
</code></pre>
<h5 id="引用类型参数">引用类型参数</h5>
<p>接口中：</p>
<pre><code class="language-java">int insertUser(User user);
</code></pre>
<p>xml配置文件中：</p>
<pre><code class="language-xml">&lt;!-- 给insert语句添加useGeneratedKeys、keyProperty后，mybatis会将自增的id值直接赋值到传进来的user对象的id属性上
        useGeneratedKeys: 指定需要获取数据库自增的id
        keyProperty: 指定自增地段的名称
     --&gt;
&lt;insert id=&quot;insertUser&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
    insert into user (username,nick_name,email)
    values (#{username},#{nickName},#{email})
&lt;/insert&gt;
</code></pre>
<h5 id="当接口中参数和xml配置取值时名称不一样时">当接口中参数和XML配置取值时名称不一样时</h5>
<p>在接口中的参数前加注解</p>
<pre><code class="language-java">User queryUserById(@Param(&quot;id&quot;) Integer xxxxxxxId);
</code></pre>
<p>在XML中取值时用注解指定的名称</p>
<pre><code class="language-xml">&lt;select id=&quot;queryUserById&quot; resultType=&quot;user&quot;&gt;
    select * from user where id = #{id}
&lt;/select&gt;
</code></pre>
<h5 id="与的区别">#{}与${}的区别</h5>
<ul>
<li>它俩都可以获取接口调用中传递过来的参数</li>
<li>#{}会将参数作为占位符，使用预编译语句(PreparedStatement)执行</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow></mrow><mi mathvariant="normal">会</mi><mi mathvariant="normal">直</mi><mi mathvariant="normal">接</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">实</mi><mi mathvariant="normal">际</mi><mi mathvariant="normal">参</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">替</mi><mi mathvariant="normal">换</mi></mrow><annotation encoding="application/x-tex">{}会直接用实际参数替换</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord"></span><span class="mord cjk_fallback">会</span><span class="mord cjk_fallback">直</span><span class="mord cjk_fallback">接</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">实</span><span class="mord cjk_fallback">际</span><span class="mord cjk_fallback">参</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">替</span><span class="mord cjk_fallback">换</span></span></span></span>{}， 参数可以作为SQL的一部分。</li>
</ul>
<h4 id="结果集如何映射">结果集如何映射</h4>
<h5 id="resulttype方式">ResultType方式</h5>
<p>ResultType方式适用于数据库结果集可以直接映射成一个Java类的情况</p>
<p>Java实体类：</p>
<pre><code class="language-java">@Getter
@Setter
@ToString
public class User {
    private Integer id;
    private String username;
    private String nickName;
    private String password;
    private String email;
    private Timestamp lastLoginTime;
}
</code></pre>
<p>使用方法：</p>
<pre><code class="language-xml">&lt;select id=&quot;queryAllUser&quot; resultType=&quot;com.lanou3g.bean.User&quot;&gt;
    select * from user
&lt;/select&gt;
</code></pre>
<h5 id="resultmap方式">ResultMap方式</h5>
<p>ResultMap方式适用于复杂的结果集映射，比如数据库返回的结果集中的列名和JavaBean无法一一对应，或者对象间存在一对一、一对多关联映射时。</p>
<h6 id="解决数据库列名与java类中属性名不一致的映射问题">解决数据库列名与Java类中属性名不一致的映射问题</h6>
<pre><code class="language-xml">&lt;mapper&gt;
    ...
    &lt;resultMap id=&quot;userMap&quot; type=&quot;user&quot;&gt;
        &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;
        &lt;result property=&quot;username&quot; column=&quot;username&quot; /&gt;
        &lt;result property=&quot;lastLoginttime&quot; column=&quot;last_login_time&quot; /&gt;
        &lt;result property=&quot;email&quot; column=&quot;email&quot; /&gt;
        &lt;result property=&quot;nickName&quot; column=&quot;nick_name&quot; /&gt;
    &lt;/resultMap&gt;
    ...
&lt;/mapper&gt;
</code></pre>
<p>在查询语句中将resultType换成resultMap</p>
<pre><code class="language-xml">&lt;select id=&quot;queryAllUser&quot; resultMap=&quot;userMap&quot;&gt;
    select * from user
&lt;/select&gt;
</code></pre>
<blockquote>
<p>其实，如果遇到单纯字段名和属性名不对应的情况，使用别名的方式更简单</p>
</blockquote>
<h6 id="解决一对一映射和一对多映射的查询问题">解决一对一映射和一对多映射的查询问题</h6>
<pre><code class="language-xml">&lt;resultMap id=&quot;star&quot; type=&quot;star&quot;&gt;
        &lt;id column=&quot;sid&quot; property=&quot;id&quot;/&gt;
        &lt;result column=&quot;sname&quot; property=&quot;name&quot;/&gt;
        &lt;collection property=&quot;jingjiren&quot; ofType=&quot;jingjiren&quot; resultMap=&quot;jingJiRenMap&quot;/&gt;
        &lt;collection property=&quot;fans&quot; ofType=&quot;fans&quot; resultMap=&quot;fansMap&quot;/&gt;
&lt;/resultMap&gt;
&lt;resultMap id=&quot;fansMap&quot; type=&quot;fans&quot; &gt;
    &lt;id column=&quot;fid&quot; property=&quot;id&quot;/&gt;
    &lt;result column=&quot;fname&quot; property=&quot;name&quot;/&gt;
    &lt;result column=&quot;fsid&quot; property=&quot;sid&quot;/&gt;
&lt;/resultMap&gt;
&lt;resultMap id=&quot;jingJiRenMap&quot; type=&quot;JingJiRen&quot; &gt;
    &lt;id column=&quot;jid&quot; property=&quot;id&quot;/&gt;
    &lt;result column=&quot;jname&quot; property=&quot;name&quot;/&gt;
    &lt;result column=&quot;jsid&quot; property=&quot;sid&quot;/&gt;
&lt;/resultMap&gt;

&lt;select id=&quot;starMapper&quot; resultMap=&quot;star&quot;&gt;
    SELECT
        star.id sid,
        star.name sname,
        fans.id fid,
        fans.sid fsid,
        fans.name fname,
        zhuli.name jname,
        zhuli.id jid,
        zhuli.sid jsid
    FROM
        star
    JOIN fans ON fans.sid = star.id
    JOIN zhuli ON zhuli.sid = star.id
    where star.id = 1
&lt;/select&gt;
</code></pre>
<h4 id="动态sql">动态SQL</h4>
<h5 id="条件分支sql">条件分支SQL</h5>
<ul>
<li>
<p>if</p>
<pre><code class="language-xml">&lt;select id=&quot;findStudent&quot; resultType=&quot;com.lanou.bean.User&quot;&gt;
     select * from user
     &lt;where&gt;
     	&lt;if test=&quot;sex != null&quot; &gt;
     	   sex = #{sex}
     	&lt;/if&gt;
     	&lt;if test=&quot;name != null&quot; &gt;
     	    and name = #{name}
     	&lt;/if&gt;
     &lt;/where&gt;
&lt;/select&gt;
</code></pre>
</li>
<li>
<p>choose&amp;when&amp;otherwise</p>
<pre><code class="language-xml">&lt;select id=&quot;queryAllUserByCondition&quot; resultType=&quot;user&quot;&gt;
    SELECT * from user
	&lt;choose&gt;
		&lt;when test=&quot;nickName != null&quot;&gt;
		    nick_name like #{nickName}
		&lt;/when&gt;
		&lt;when test=&quot;status != null&quot;&gt;
		    and `status` = #{status};
		&lt;/when&gt;
		&lt;otherwise&gt;
		    and 1 = 1
		&lt;/otherwise&gt;
	&lt;/choose&gt;       
 &lt;/select&gt;
</code></pre>
</li>
</ul>
<h5 id="循环sql">循环SQL</h5>
<ul>
<li>
<p>forEach</p>
<pre><code class="language-xml">&lt;insert id=&quot;insertManyFans&quot; &gt;
	INSERT INTO fans VALUES
     &lt;!--
		collection 当前不要遍历的对象 
		separator 遍历完一次后，在末尾添加的字符等。 
		open 遍历的sql以什么开头 
		close 遍历的sql以什么结尾
	--&gt;
	&lt;foreach collection=&quot;list&quot; item=&quot;fans&quot; separator=&quot;,&quot;&gt;
	    (#{fans.id}, #{fans.name}, #{fans.sid})
	&lt;/foreach&gt;
&lt;/insert&gt;
</code></pre>
</li>
</ul>
<h5 id="其他特殊sql">其他特殊SQL</h5>
<ul>
<li>
<p>where</p>
<pre><code class="language-xml">&lt;!-- 
where元素只会在至少有一个子元素的条件返回 SQL 子句的情况下才去插入“WHERE”子句。
如果输出后语句的开头为“AND”或“OR”，where元素也会将它们去除。 
 --&gt;
&lt;select id=&quot;dynamicWhereTest&quot; parameterType=&quot;Blog&quot; resultType=&quot;Blog&quot;&gt;
	select * from t_blog 
	&lt;where&gt;
	    &lt;if test=&quot;title != null&quot;&gt;
	        title = #{title}
	    &lt;/if&gt;
	    &lt;if test=&quot;content != null&quot;&gt;
	        and content = #{content}
	    &lt;/if&gt;
	    &lt;if test=&quot;owner != null&quot;&gt;
	        and owner = #{owner}
	    &lt;/if&gt;
	&lt;/where&gt;
&lt;/select&gt;
&lt;!-- 
	如果 title=null， 而 content != null，那么输出的整个语句会是 
		select * from t_blog where content = #{content}
	而不是 
		select * from t_blog where and content = #{content}
	因为 MyBatis 会自动地把首个 and / or 给忽略。
--&gt;
</code></pre>
</li>
<li>
<p>set</p>
<pre><code class="language-xml">&lt;!-- 
	set元素可以用于动态包含需要更新的列，而舍去其它的 
	set元素会动态前置 SET 关键字，同时也会删掉无关的逗号 , 因为用了条件语句之后很可能就会在生	成的 SQL 语句的后面留下这些逗号  
--&gt;
&lt;update id=&quot;updateAuthorIfNecessary&quot;&gt;
  update Author
	&lt;set&gt;
		&lt;if test=&quot;username != null&quot;&gt;
            username=#{username},
        &lt;/if&gt;
		&lt;if test=&quot;password != null&quot;&gt;
            password=#{password},
        &lt;/if&gt;
	&lt;/set&gt;
  where 
    id=#{id}
&lt;/update&gt;
</code></pre>
</li>
<li>
<p>trim</p>
<ul>
<li>
<p>去除sql语句中多余的and关键字，逗号</p>
</li>
<li>
<p>给sql语句前拼接 “where“、“set“以及“values(“ 等前缀，或者添加“)“等后缀，</p>
</li>
<li>
<p>可用于选择性插入、更新、删除或者条件查询等操作。</p>
</li>
</ul>
<pre><code class="language-xml">&lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;AND |OR &quot; /&gt;
  	&lt;!-- 
	prefix 	给sql语句拼接的前缀
	suffix 	给sql语句拼接的后缀
	prefixOverrides 	去除sql语句前面的关键字或者字符，该关键字或者字符由prefixOverrides属性指定，假设该属性指定为&quot;AND&quot;，当sql语句的开头为&quot;AND&quot;，trim标签将会去除该&quot;AND&quot;
	suffixOverrides 	去除sql语句后面的关键字或者字符，该关键字或者字符由suffixOverrides 属性指定
	--&gt;  
</code></pre>
</li>
</ul>
<h4 id="批量插入">批量插入</h4>
<h5 id="通过foreach动态sql方式">通过forEach动态SQL方式</h5>
<pre><code class="language-java">public static void main( String[] args ) throws IOException {  
    String confPath = &quot;newmybaits.xml&quot;;
    InputStream in = Resources.getResourceAsStream(confPath); 
    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in);
    SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH,true);
    StarDao starDao = sqlSession.getMapper(StarDao.class);
    testInsertManyFans1(starDao,sqlSession);
}
public static void testInsertManyFans(StarDao starDao,SqlSession sqlSession){
    //制造数据
    List&lt;Fans&gt; fansList = new ArrayList&lt;&gt;();
	for(int i = 110; i &lt;= 510; i++ ){
	    Fans fans = new Fans(&quot;张三&quot; + i, i, 1);
	    fansList.add(fans);
	}
    //批量插入数据（返回值为int表示成功插入的总数居条数）
	starDao.insertManyFans(fansList);
	sqlSession.flushStatements();
}
</code></pre>
<h5 id="通过executorbatch的方式">通过Executor.BATCH的方式</h5>
<pre><code class="language-java">public static void main( String[] args ) throws IOException {  
    String confPath = &quot;newmybaits.xml&quot;;
    InputStream in = Resources.getResourceAsStream(confPath); 
    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in);
    SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH,true);
    StarDao starDao = sqlSession.getMapper(StarDao.class);
    testInsertManyFans2(starDao,sqlSession);
}

public static void testInsertManyFans2(StarDao starDao,SqlSession sqlSession){
	List&lt;Fans&gt; fansList = new ArrayList&lt;&gt;();
	List&lt;BatchResult&gt; resultList = new ArrayList&lt;&gt;();
	//制造数据
    for(int i = 511; i &lt;= 610; i++ ){
	    Fans fans = new Fans(&quot;张三&quot; + i, i, 1);
	    fansList.add(fans);
	}
	int counts = 0;
    //批量插入数据
	for (Fans fans:fansList){
	    starDao.insertManyFans2(fans);
	    counts++;
    //每10条执行一次sql语句（每10条插入一次）
	    if(counts % 10 ==0){
	        resultList.addAll(sqlSession.flushStatements());
	    }
	}    
    //获取成功批量插入的数据条数
    int rows = 0;
    for(BatchResult batchResult : resultList) {
        int[] updateCounts = batchResult.getUpdateCounts();
        for(int updateCount : updateCounts) {
            rows += updateCount;
        }
    }
    System.out.println(&quot;批量插入成功，响应的行数：&quot; + rows);
}
</code></pre>
<h4 id="缓存">缓存</h4>
<h5 id="一级缓存本地缓存">一级缓存（本地缓存）</h5>
<h6 id="一级缓存概述">一级缓存概述</h6>
<p>​		Mybatis的一级缓存是指Session缓存。一级缓存的作用域默认是一个SqlSession。Mybatis默认开启一级缓存。 也就是在同一个SqlSession中，执行相同的查询SQL，第一次会去数据库进行查询，并写到缓存中；<br>
第二次以后是直接去缓存中取。当执行SQL查询中间发生了增删改的操作，MyBatis会把SqlSession的缓存清空。</p>
<h6 id="一级缓存的使用">一级缓存的使用</h6>
<ol>
<li>我们在一个 sqlSession 中，对 User 表根据id进行两次查询，查看他们发出sql语句的情况</li>
</ol>
<pre><code class="language-java">@Test
public void testSelectOrderAndUserByOrderId(){
    //根据 sqlSessionFactory 产生 session
    SqlSession sqlSession = sessionFactory.openSession();
    String statement = &quot;one.to.one.mapper.OrdersMapper.selectOrderAndUserByOrderID&quot;;
    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
    //第一次查询，发出sql语句，并将查询的结果放入缓存中
    User u1 = userMapper.selectUserByUserId(1);
    System.out.println(u1);
     
    //第二次查询，由于是同一个sqlSession,会在缓存中查找查询结果
    //如果有，则直接从缓存中取出来，不和数据库进行交互
    User u2 = userMapper.selectUserByUserId(1);
    System.out.println(u2);
     
    sqlSession.close();
}
</code></pre>
<ol start="2">
<li>同样是对user表进行两次查询，只不过两次查询之间进行了一次update操作。</li>
</ol>
<pre><code class="language-java">@Test
public void testSelectOrderAndUserByOrderId(){
    //根据 sqlSessionFactory 产生 session
    SqlSession sqlSession = sessionFactory.openSession();
    String statement = &quot;one.to.one.mapper.OrdersMapper.selectOrderAndUserByOrderID&quot;;
    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
    //第一次查询，发出sql语句，并将查询的结果放入缓存中
    User u1 = userMapper.selectUserByUserId(1);
    System.out.println(u1);
     
    //第二步进行了一次更新操作，sqlSession.commit()
    u1.setSex(&quot;女&quot;);
    userMapper.updateUserByUserId(u1);
    sqlSession.commit();
     
    //第二次查询，由于是同一个sqlSession.commit(),会清空缓存信息
    //则此次查询也会发出 sql 语句
    User u2 = userMapper.selectUserByUserId(1);
    System.out.println(u2);
     
    sqlSession.close();
}
</code></pre>
<p>​	<img src="C:%5CUsers%5CWangbo%5CDesktop%5C%E6%96%87%E4%BB%B6%5Cmkd%5C%E7%8E%8B%E6%B3%A2%E5%91%A8%E6%80%BB%E7%BB%93%5CO8X132PM97S_%7DUXEG5RC%60~M.png" alt="一级缓存"></p>
<h5 id="二级缓存全局缓存">二级缓存（全局缓存）</h5>
<h6 id="二级缓存概述">二级缓存概述</h6>
<p>​		Mybatis的二级缓存是指mapper映射文件。二级缓存的作用域是同一个namespace下的mapper映射文件内容，多个SqlSession共享。Mybatis需要手动设置启动二级缓存。</p>
<h6 id="二级缓存的使用">二级缓存的使用</h6>
<p>1.在 SqlMapConfig.xml 文件开启二级缓存</p>
<pre><code class="language-xml">&lt;settings&gt; 
    &lt;!-- 开启二级缓存的支持 --&gt;  
    &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; 
&lt;/settings&gt; 
</code></pre>
<p>2.配置相关的 Mapper 映射文件</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; 
&lt;!DOCTYPE mapper     
PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;     
&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; 
&lt;mapper namespace=&quot;com.itheima.dao.IUserDao&quot;&gt;  
    &lt;!-- 开启二级缓存的支持 --&gt;  
    &lt;cache&gt;&lt;/cache&gt; 
&lt;/mapper&gt;
</code></pre>
<blockquote>
<p><cache>标签表示当前这个 mapper 映射将使用二级缓存，区分的标准就看 mapper 的 namespace 值。</p>
</blockquote>
<p>3.配置 statement 上面的 useCache 属性</p>
<pre><code class="language-xml">&lt;!-- 根据 id 查询 --&gt; 
&lt;select id=&quot;findById&quot; resultType=&quot;user&quot; parameterType=&quot;int&quot; useCache=&quot;true&quot;&gt;  
    select * from user where id = #{uid} 
&lt;/select&gt; 
</code></pre>
<blockquote>
<p>将 UserDao.xml 映射文件中的<select>标签中设置 useCache=”true”代表当前这个 statement 要使用 二级缓存，如果不使用二级缓存可以设置为 false。</p>
<p>注意：</p>
<p>针对每次查询都需要最新的数据 sql，要设置成 useCache=false，禁用二级缓存。</p>
<p>当我们在使用二级缓存时，所缓存的类一定要实现 java.io.Serializable 接口，这种就可以使用序列化 方式来保存对象。</p>
<pre><code class="language-java">public class User implements Serializable { }
</code></pre>
</blockquote>
<h1 id="spring与mybatis整合">Spring与Mybatis整合</h1>
<h2 id="使用步骤">使用步骤</h2>
<ol>
<li>
<p>加入依赖</p>
<pre><code class="language-xml">&lt;!-- mybatis-spring整合依赖，这个是最主要的一个依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
    &lt;version&gt;2.0.1&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- Spring和数据源相关依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
    &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
    &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;druid&lt;/artifactId&gt;
    &lt;version&gt;1.1.20&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>在Spring bean配置文件中配置Mybatis、Spring整合bean  SqlSessionFactoryBean</p>
<pre><code class="language-xml">&lt;!-- 配置整合bean --&gt;
&lt;bean id=&quot;sessionFactoryBean&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
    &lt;!-- 数据源是必要参数 --&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
    &lt;!-- Mybatis核心配置文件其实大多数情况下都可以省略，通过指定属性可以间接设置核心配置文件中的参数 --&gt;
    &lt;!--&lt;property name=&quot;configLocation&quot; value=&quot;mybatis_conf.xml&quot; /&gt;--&gt;

    &lt;!-- 省略mybatis核心配置文件后，可以通过类似下面这些特定属性，设置mybatis参数 --&gt;
    &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.lanou3g.mybatis.spring.bean&quot; /&gt;
    &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot; /&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>在Spring bean配置文件中开启Mybatis Mapper扫描</p>
<ol>
<li>
<p>需要使用mybatis schema</p>
<p>配置方法，在bean配置文件的头部添加</p>
<pre><code class="language-xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mybatis=&quot;http://mybatis.org/schema/mybatis-spring&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd
        http://mybatis.org/schema/mybatis-spring
        http://mybatis.org/schema/mybatis-spring.xsd&quot;&gt;
</code></pre>
</li>
<li>
<p>开启Mybatis Mapper扫描</p>
<p>开启Mybatis Mapper扫描的作用是：告诉Mybatis要创建哪个包下接口的实现类，并以bean的方式加入到SpringIOC容器中</p>
<pre><code class="language-xml">&lt;!-- 开启Mapper扫描，Mybatis会创建将此包下的接口的实现类，并以bean的方式加入到SpringIOC容器中 --&gt;
&lt;mybatis:scan base-package=&quot;com.lanou3g.mybatis.spring.mapper&quot; /&gt;
</code></pre>
</li>
</ol>
</li>
<li>
<p>创建实体类、mapper映射文件、Mapper接口（可以通过Mybatis逆向工程直接生成）</p>
<p>Mapper接口</p>
<pre><code class="language-java">@Repository	//此注解不是必须的，因为MessageMapper类的实现类是由Mybatis创建并放到ioc容器中的，不是由Spring来创建的。
public interface MessageMapper {
    int insert(Message record);
    List&lt;Message&gt; selectAll();
}
</code></pre>
<p>实体类、映射文件 略</p>
</li>
<li>
<p>将Mapper接口用Spring自动注入的方式注入到需要的地方使用</p>
<p>MessageService.java</p>
<pre><code class="language-java">@Service
public class MessageService {
    @Autowired
    MessageMapper messageMapper;
    public List&lt;Message&gt; queryAllMessage() {
        return messageMapper.selectAll();
    }
}
</code></pre>
</li>
</ol>

            </div>
          </article>
        </div>
        <div class="paper" data-aos="fade-in">
          
            <div class="next-post">
              <div class="next">
                下一篇
              </div>
              <a href="https://tangsongyuanmingqing1.github.io/post/springaop">
                <h3 class="post-title">
                  Spring AOP
                </h3>
              </a>
            </div>
          
        </div>
        
          
            <div class="paper" data-aos="fade-in">
              <div id="gitalk-container"></div>
            </div>
          

          
        
      </div>

      <div class="sm-12 md-4 col sidebar">
  <div class="paper info-container">
    <img src="https://tangsongyuanmingqing1.github.io/images/avatar.png?v=1576068226601" class="no-responsive avatar">
    <div class="text-muted"><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1576067917477&di=981af9e2e885994371221c478cfd625d&imgtype=jpg&src=http%3A%2F%2Fimg1.imgtn.bdimg.com%2Fit%2Fu%3D1205038546%2C1747959657%26fm%3D214%26gp%3D0.jpg" /></div>
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
  </div>
  <div class="paper">
    <div class="sidebar-title">
      最新文章
    </div>
    <div class="row">
      <ul>
        
          
            <li>
              <a href="https://tangsongyuanmingqing1.github.io/post/mybatis-kuang-jia-xue-xi-bi-ji">Mybatis框架学习笔记</a>
            </li>
          
        
          
            <li>
              <a href="https://tangsongyuanmingqing1.github.io/post/spring-mvc">Spring MVC</a>
            </li>
          
        
          
            <li>
              <a href="https://tangsongyuanmingqing1.github.io/post/springaop">Spring AOP</a>
            </li>
          
        
          
            <li>
              <a href="https://tangsongyuanmingqing1.github.io/post/spring-di">Spring DI</a>
            </li>
          
        
          
            <li>
              <a href="https://tangsongyuanmingqing1.github.io/post/springioc">Spring IOC</a>
            </li>
          
        
          
            <li>
              <a href="https://tangsongyuanmingqing1.github.io/post/cookieandsession">Cookie&amp;Session</a>
            </li>
          
        
          
            <li>
              <a href="https://tangsongyuanmingqing1.github.io/post/wen-jian-shang-chuan">文件上传</a>
            </li>
          
        
          
            <li>
              <a href="https://tangsongyuanmingqing1.github.io/post/shu-ju-fen-ye">数据分页</a>
            </li>
          
        
          
            <li>
              <a href="https://tangsongyuanmingqing1.github.io/post/nei-bu-lei">内部类</a>
            </li>
          
        
          
            <li>
              <a href="https://tangsongyuanmingqing1.github.io/post/fan-xing">泛型</a>
            </li>
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      </ul>
    </div>
  </div>
  <div class="paper">
    <div class="sidebar-title">
      标签列表
    </div>
    <div class="row">
      
        <a href="https://tangsongyuanmingqing1.github.io/tag/ESFD3Nrtm" class="badge secondary">
          Mybaits
        </a>
      
        <a href="https://tangsongyuanmingqing1.github.io/tag/7i8WPTon8" class="badge success">
          spring
        </a>
      
        <a href="https://tangsongyuanmingqing1.github.io/tag/17j_CC3dY" class="badge secondary">
          JavaEE
        </a>
      
        <a href="https://tangsongyuanmingqing1.github.io/tag/xIc22-S6w" class="badge warning">
          JavaSE
        </a>
      
    </div>
  </div>
  <div class="paper">
    <p>联系方式   |  150 3876 2003</p>
<p>邮&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp箱   |  tangsongYMQ715417@163.com</p>
<p>微&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp信   |  150 3876 2003</p>
<p>Q&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbspQ&nbsp&nbsp|  1765706237</p> | <a class="rss" href="https://tangsongyuanmingqing1.github.io/atom.xml" target="_blank">RSS</a>
  </div>
</div>


    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>

<script type="application/javascript">

AOS.init();

hljs.initHighlightingOnLoad()

</script>



  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '809a698b6fca6a0d6dc6',
        clientSecret: 'bcda78cc30e17669ec10209d6d09e3a24d87f907',
        repo: 'tangsongyuanmingqing1.github.io',
        owner: 'tangsongyuanmingqing1',
        admin: ['tangsongyuanmingqing1'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
